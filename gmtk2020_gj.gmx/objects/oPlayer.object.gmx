<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerOld</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>oEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player
/// Setup the basic property
ent_init();
fsm_init();

// (fsm)
fsm_add_state("spawn_fall", plr_state_spawn_fall);
fsm_add_state("default", plr_state_normal);
fsm_add_state("kick_dash", plr_state_kick_dash); // initial kick's dash duration
fsm_add_state("kick_knockback", plr_state_kick_knockback); // after kick has hit something
fsm_add_state("kick_down", plr_state_kick_down); // kick state after initial dash duration
fsm_add_state("kick", plr_state_kick); // kick state after initial dash duration
fsm_add_state("hurt", plr_state_hurt); // player hurt knockback
fsm_add_state("dead", plr_state_dead); // player dead
fsm_add_state("interact", plr_state_interact); // interaction state (disable inputs)

/// Input
// (binds)
inputBindL = vk_left;
inputBindR = vk_right;
inputBindU = vk_up;
inputBindD = vk_down;
inputBindJump   = ord('Z');
inputBindShoot  = ord('X');
inputBindSprint = vk_shift;
// (input states)
// hold, press, release
inputH = 0; // horizontal input
inputV = 0; // vertical input
inputJump   = makearray(false, false, false); // jump
inputSprint = makearray(false, false, false); // sprint
inputShoot  = makearray(false, false, false); // shoot

/// Player attributes
// (stats)
hp          = 5;
hpMaxDefault= 5;
hpMax       = hpMaxDefault;

// (upgrades)
upgradeMove     = true;
upgradeJump     = true;
upgradeSprint   = true;
upgradeKick     = true;
upgradeWeapon   = true;

// (basic movement)
isMoving        = false;
isFastfalling   = false;
isSprinting     = false;
moveFacing  = 1;
moveVelAccDefault   = 0.2;
moveVelAccSprint    = 0.25;
moveVelAccCrawl     = 0.1;
moveVelMaxDefault   = 3;
moveVelMaxSprint    = 4;
moveVelMaxCrawl     = 1.5;
moveVelAcc  = moveVelAccDefault;
moveVelMax  = moveVelMaxDefault;
moveVelInit = 0.75; // initial boost

moveFootstepPlayed  = false;
moveFootstepFlip    = 1;

// (gravity)
velGravAccDefault   = 0.3;  // default gravity accel applied
velGravAccJump      = 0.2; // gravity accel applied when player is jumping
velGravAccKick      = 0.1; // gravity accel applied when player is kicking
velGravAccFastfall  = 0.4; // gravity accel applied when player is holding down
velGravAcc          = velGravAccDefault;
velGravMax = 6;

// (jump)
isJumping       = false;
jumpVelInit     = 4;
jumpVelAccMin   = 0.01;
jumpVelAccMax   = 0.2;
jumpFramesMax   = 15;
jumpFrames      = jumpFramesMax;

// (air kick)
kickDashSaveVel     = 0; // stored y-veloctiy of player before applying dash velocity
kickDashSaveMaxVY   = 2; // maximum stored velocity that can influence the wall boosting
kickDashSaveFactor  = 0.5; // factor multiplied to original y-velocity before storing it into the stored velocity
kickDashFrames      = 8; // duration of dash
kickDashVelSprint   = 8; // velocity of dash (sprinting)
kickDashVelDefault  = 6; // velocity of dash
kickDashVel         = kickDashVelDefault; // velocity of dash
kickDashEndVel      = 4; // end velocity of dash
kickDashDirX        = 1; // direction of dash
kickDashDirY        = 0; // direction of dash
kickKnockbackFrames     = 30;
kickKnockbackStunFrames = 16; // duration before regaining controls
kickKnockbackVel    = 3; // horiznotal velocity applied when player has kicked against the wall
kickWallBoostVel    = 4.5; // velocity applied when player has kicked against the wall
kickWallBonkVel     = 1; // velocity applied when player has collided against the wall while in normal kick state
kickKnockbackDamp   = 0.9; // velocity dampening factor in kick knockback state

// (down kick)
kickDownDiveVel     = 8; // downward velocity of divekick
kickDownControlVel  = 1; // maximum velocity of movement while in this state
kickDownBounceVel       = 3; // bounce-off velocity
kickDownBounceVelHigh   = 5; // bounce-off velocity applied when holding down the jump button

// (attack)
isCharging = false;
shootCooldownFramesMax  = 4;
shootCooldownFrames     = shootCooldownFramesMax;
shootChargeCtr = 0;
shootChargeMax = 60;
shootDamageMin = 2; // minimum damage
shootDamageMax = 5; // maximum charge damage
shootThickMin  = 1; // minimum laser thickness
shootThickMax  = 10; // maximum laser thickness

shootChargeSnd = -1;

// (hurt / knockback)
hurtFrames      = 30;
hurtStunFrames  = 10;
hurtKnockbackX  = 3;
hurtKnockbackY  = 4;

/// Visuals
anim_init();
anim_add_anim("idle", plr_anim_idle);
anim_add_anim("spawn_fall", plr_anim_spawn_fall);
anim_add_anim("move", plr_anim_move);
anim_add_anim("move_crawl", plr_anim_move_crawl);
anim_add_anim("jump", plr_anim_jump);
anim_add_anim("midair", plr_anim_midair);
anim_add_anim("midair_crawl", plr_anim_midair_crawl);
anim_add_anim("kick_dash", plr_anim_kick_dash);
anim_add_anim("kick_knockback", plr_anim_kick_knockback);
anim_add_anim("kick_down", plr_anim_kick_down);
anim_add_anim("kick", plr_anim_kick);
anim_add_anim("hurt", plr_anim_hurt);
anim_add_anim("dead", plr_anim_dead);
anim_add_anim("interact", plr_anim_interact);
anim_fire("idle");

// Set some animation variables
with (animator)
{
    moveCtr = 0;
}
image_speed = 0;

/// Debug
debugShowStates = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Delete child objects
anim_destroy();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free allocated memories
/// FSM
fsm_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update FSM

// Check for paused
if (global.isPhysicsPaused)
    exit;

fsm_update();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update upgrades status
// Reset all upgrade stats first
event_user(0);

// Loop through all the inventory &amp; check for upgrades
var _slots = oGamevars.invSlots;
for (var i=0; i&lt;ds_list_size(_slots); i++)
{
    var _data = _slots[| i];
    switch (_data[@ eINVKEY.ITEM])
    {
        case eITEM.UPGRADE_MOBILITY:
            upgradeMove = true;
            break;
            
        case eITEM.UPGRADE_JUMP:
            upgradeJump = true;
            
            // bind the jump key to the upgrade item slot's keycode
            inputBindJump = _data[@ eINVKEY.KEYCODE];
            break;
            
        case eITEM.UPGRADE_KICK:
            upgradeKick = true;
            break;
            
        case eITEM.UPGRADE_SPRINT:
            upgradeSprint = true;
            
            // bind the sprint key to the upgrade item slot's keycode
            inputBindSprint = _data[@ eINVKEY.KEYCODE];
            break;
            
        case eITEM.UPGRADE_WEAPON:
            upgradeWeapon = true;
            
            // bind the sprint key to the upgrade item slot's keycode
            inputBindShoot = _data[@ eINVKEY.KEYCODE];
            break;
            
        case eITEM.UPGRADE_HP:
            hpMax += oGamevars.itemHealthIncreaseAmount;
            break;
    }
}

// Update player HP
hp = clamp(hp, 0, hpMax);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset all upgrades status from player
upgradeMove     = false;
upgradeJump     = false;
upgradeKick     = false;
upgradeSprint   = false;
upgradeWeapon   = false;

hpMax = hpMaxDefault;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw player sprite with animation variable applied
// Calculate final values
var _x = x + animator.x + random_range(-animator.animFXShake, animator.animFXShake);
var _y = y + animator.y + random_range(-animator.animFXShake, animator.animFXShake);
var _xscale = (image_xscale + animator.animFXSqueeze) * animator.image_xscale * moveFacing;
var _yscale = (image_yscale - animator.animFXSqueeze) * animator.image_yscale;
var _rot    = image_angle + random_range(-animator.animFXShake, animator.animFXShake) + animator.image_angle;
draw_sprite_ext(sprite_index, image_index, _x, _y, _xscale, _yscale, _rot, image_blend, image_alpha);

// Draw states
if (debugShowStates)
{
    var _msg = "STATE : " + fsmState + "#ANIM : " + animator.fsmState + "#JUMP : " + string(isJumping) +  " | GRAV : " + string(velGravAcc);
    draw_set_halign(1); draw_set_valign(2);
    draw_text(x, bbox_top - 32, _msg);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
