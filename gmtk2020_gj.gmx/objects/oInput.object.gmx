<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input manager

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// singleton check
if (!singleton_update())
    exit;
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Declare input variables
/// Globally used inputs
enum eINPUT
{
    HLD = 0,
    PRS,
    REL
}

// keyboard
// (generic)
inputBindKeyboardL = vk_left;
inputBindKeyboardR = vk_right;
inputBindKeyboardU = vk_up;
inputBindKeyboardD = vk_down;
inputBindKeyboardConfirm = vk_enter;
inputBindKeyboardDeny    = vk_escape;
// (keyslot)
inputBindKeyboardKey1 = ord('Z');
inputBindKeyboardKey2 = ord('X');
inputBindKeyboardKey3 = ord('C');
inputBindKeyboardKey4 = ord('V');
inputBindKeyboardKey5 = vk_shift;

// gamepad
inputBindGamepadL = gp_padl;
inputBindGamepadR = gp_padr;
inputBindGamepadU = gp_padu;
inputBindGamepadD = gp_padd;
inputBindGamepadConfirm     = gp_face1; // A / CROSS button
inputBindGamepadDeny        = gp_face2; // B / CIRCLE button
inputBindGamepadConfirmAlt  = gp_select;
inputBindGamepadDenyAlt     = gp_start;
// (keyslot)
inputBindGamepadKey1 = gp_face1;
inputBindGamepadKey2 = gp_face2;
inputBindGamepadKey3 = gp_face3;
inputBindGamepadKey4 = gp_face4;
inputBindGamepadKey5 = makearray(gp_shoulderl, gp_shoulderlb, gp_shoulderr, gp_shoulderrb);

inputH = makearray(false, false, false);
inputV = makearray(false, false, false);
inputConfirm    = makearray(false, false, false); // yes
inputDeny       = makearray(false, false, false); // no
// (keyslot)
inputKey1       = makearray(false, false, false);
inputKey2       = makearray(false, false, false);
inputKey3       = makearray(false, false, false);
inputKey4       = makearray(false, false, false);
inputKey5       = makearray(false, false, false);

/// Current / preferred input method
enum eINPUT_METHOD
{
    KEYBOARD = 0,
    GAMEPAD
}

// Table to convert the method index to string
inputMethodNameStr = -1;
inputMethodNameStr[eINPUT_METHOD.KEYBOARD] = "KEYBOARD";
inputMethodNameStr[eINPUT_METHOD.GAMEPAD] = "GAMEPAD";

// Current method
inputMethodCurrent = eINPUT_METHOD.KEYBOARD;

// Current input device
inputDevice = 0;

/// Gamepad specific vars
inputGamepadList = ds_list_create();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup keyslot system
/// Enum : inventory key slot data
enum eINVKEY
{
    KEY = 0, // key state
    AVAILABLE,
    ID,
    ITEM
}

invSlots = ds_list_create();
inv_key_add(ord("A"), true, "BTN1");
inv_key_add(ord("S"), true, "BTN2");
inv_key_add(ord("Z"), false, "BTN3");
inv_key_add(ord("X"), false, "BTN4");
inv_key_add(vk_shift, false, "BTN5");

/// Table of keys unlocking on each level
invKeysUnlock = makearray(
    makearray("BTN1", "BTN1"),
    makearray(vk_shift),
    makearray(ord("A")),
    makearray(ord("S"))
    );
invKeysLevel = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free data structures
if (objectInitialized)
{
    ds_list_destroy(inputGamepadList);
    
    /// Key slot system
    if (ds_exists(invSlots, ds_type_list))
        ds_list_destroy(invSlots);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update input
/// Check for inputs
switch (inputMethodCurrent)
{
    case eINPUT_METHOD.KEYBOARD:
        /// Check for keyboard inputs
        // (horizontal)
        inputH[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardR) - keyboard_check(inputBindKeyboardL);
        inputH[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardR) - keyboard_check_pressed(inputBindKeyboardL);
        inputH[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardR) - keyboard_check_released(inputBindKeyboardL);
        
        // (vertical)
        inputV[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardD) - keyboard_check(inputBindKeyboardU);
        inputV[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardD) - keyboard_check_pressed(inputBindKeyboardU);
        inputV[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardD) - keyboard_check_released(inputBindKeyboardU);
        
        // (confirm)
        inputConfirm[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardConfirm);
        inputConfirm[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardConfirm);
        inputConfirm[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardConfirm);
        
        // (deny)
        inputDeny[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardDeny);
        inputDeny[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardDeny);
        inputDeny[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardDeny);
        
        // (keyslots)
        inputKey1[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey1);
        inputKey1[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey1);
        inputKey1[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey1);
        inputKey2[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey2);
        inputKey2[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey2);
        inputKey2[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey2);
        inputKey3[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey3);
        inputKey3[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey3);
        inputKey3[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey3);
        inputKey4[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey4);
        inputKey4[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey4);
        inputKey4[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey4);
        inputKey5[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey5);
        inputKey5[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey5);
        inputKey5[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey5);
        break;
        
    case eINPUT_METHOD.GAMEPAD:
        /// Check for gamepad inputs
        // (horizontal)
        inputH[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadR) - gamepad_button_check(inputDevice, inputBindGamepadL);
        inputH[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadR) - gamepad_button_check_pressed(inputDevice, inputBindGamepadL);
        inputH[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadR) - gamepad_button_check_released(inputDevice, inputBindGamepadL);
        
        // (vertical)
        inputV[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadD) - gamepad_button_check(inputDevice, inputBindGamepadU);
        inputV[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadD) - gamepad_button_check_pressed(inputDevice, inputBindGamepadU);
        inputV[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadD) - gamepad_button_check_released(inputDevice, inputBindGamepadU);
        
        // (alternative joystick controls)
        if (inputH[@ eINPUT.HLD] == 0)
            inputH[@ eINPUT.HLD] = gamepad_axis_value(inputDevice, gp_axislh);
        if (inputV[@ eINPUT.HLD] == 0)
            inputV[@ eINPUT.HLD] = gamepad_axis_value(inputDevice, gp_axislv);
        
        // (confirm)
        inputConfirm[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadConfirm) || gamepad_button_check(inputDevice, inputBindGamepadConfirmAlt);
        inputConfirm[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadConfirm) || gamepad_button_check_pressed(inputDevice, inputBindGamepadConfirmAlt);
        inputConfirm[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadConfirm) || gamepad_button_check_released(inputDevice, inputBindGamepadConfirmAlt);
        
        // (deny)
        inputDeny[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadDeny) || gamepad_button_check(inputDevice, inputBindGamepadDenyAlt);
        inputDeny[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadDeny) || gamepad_button_check_pressed(inputDevice, inputBindGamepadDenyAlt);
        inputDeny[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadDeny) || gamepad_button_check_released(inputDevice, inputBindGamepadDenyAlt);
        
        // (keyslots)
        inputKey1[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadKey1);
        inputKey1[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadKey1);
        inputKey1[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadKey1);
        inputKey2[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindKeyboardKey2);
        inputKey2[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindKeyboardKey2);
        inputKey2[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindKeyboardKey2);
        inputKey3[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindKeyboardKey3);
        inputKey3[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindKeyboardKey3);
        inputKey3[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindKeyboardKey3);
        inputKey4[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindKeyboardKey4);
        inputKey4[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindKeyboardKey4);
        inputKey4[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindKeyboardKey4);
        for (var i=0; i&lt;array_length_1d(inputBindGamepadKey5); i++)
        {
            var _btn = inputBindGamepadKey5[@ i];
            inputKey5[@ eINPUT.HLD] |= gamepad_button_check(inputDevice, _btn);
            inputKey5[@ eINPUT.PRS] |= gamepad_button_check_pressed(inputDevice, _btn);
            inputKey5[@ eINPUT.REL] |= gamepad_button_check_released(inputDevice, _btn);
        }
        break;
}

// Detect gamepad input
for (var i=0; i&lt;ds_list_size(inputGamepadList); i++)
{
    var _pad = inputGamepadList[| i];
    if (input_check_gamepad_anybutton(_pad))
    {
        if (inputDevice != _pad || inputMethodCurrent == eINPUT_METHOD.KEYBOARD)
        {
            // If any input was detected on current gamepad,
            // make it as the current input device and set input method to gamepad
            inputMethodCurrent = eINPUT_METHOD.GAMEPAD;
            inputDevice = _pad;
            
            // Show input detection popup
            with (oUI)
            {
                event_user(0);
            }
            
        }
        debug_log("GAMEPAD INPUT DETECTED ON GP#", _pad, "!");
    }
}

// Detect keyboard input
if (inputMethodCurrent == eINPUT_METHOD.GAMEPAD)
{
    if (keyboard_check_pressed(vk_anykey))
    {
        // If any input was detected on keyboard,
        // make it as the current input device and set input method to keyboard
        inputMethodCurrent = eINPUT_METHOD.KEYBOARD;
        inputDevice = -1;
        
        // Show input detection popup
        with (oUI)
        {
            event_user(0);
        }
        
        debug_log("KEYBOARD DETECTED!");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for gamepad connection
var _eventtype = async_load[? "event_type"];

switch (_eventtype)
{
    case "gamepad discovered": // Detected gamepad connection
        var _padindex = async_load[? "pad_index"];
        // Check if there's any gamepad present in the connected gamepad list
        // and add it to the list of connected gamepad list if not present
        var _padlistidx = ds_list_find_index(inputGamepadList, _padindex);
        if (_padlistidx == -1)
        {
            ds_list_add(inputGamepadList, _padindex);
        }
        
        // Set input method to gamepad &amp; set current input device to
        // connected gamepad
        inputMethodCurrent = eINPUT_METHOD.GAMEPAD;
        inputDevice = _padindex;
        
        // Show input detection popup
        with (oUI)
        {
            event_user(0);
        }
        
        debug_log("GAMEPAD DETECTED!");
        break;
        
    case "gamepad lost": // Lost gamepad connection
        var _padindex = async_load[? "pad_index"];
        // Check if there's any gamepad present in the connected gamepad list
        // and remove it from the list of connected gamepad list if present
        var _padlistidx = ds_list_find_index(inputGamepadList, _padindex);
        if (_padlistidx != -1)
        {
            ds_list_delete(inputGamepadList, _padlistidx);
        }
        
        // Set input method to keyboard
        // if there's no more gamepads present in the list of connected devices
        if (ds_list_empty(inputGamepadList))
        {
            inputMethodCurrent = eINPUT_METHOD.KEYBOARD;
            inputDevice = -1;
        }
        else
        {
            // Otherwise, set the input device to recently connected gamepad
            inputDevice = inputGamepadList[| ds_list_size(inputGamepadList)];
        }
        
        // Show input detection popup
        with (oUI)
        {
            event_user(0);
        }
        
        debug_log("GAMEPAD LOST!");
        break;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update key slots upgrade status
event_user(0);

invKeysLevel = clamp(invKeysLevel, 0, array_length_1d(invKeysUnlock) - 1);
for (var i=0; i&lt;=invKeysLevel; i++)
{
    var _unlocks = invKeysUnlock[@ i];
    for (var j=0; j&lt;array_length_1d(_unlocks); j++)
    {
        var _keycode = _unlocks[@ j];
        debug_log("unlocking [", chr(_keycode), " / ", _keycode, "]...");
        inv_key_set_available(_keycode, true);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset key slots upgrade status
for (var i=0; i&lt;ds_list_size(invSlots); i++)
{
    var _keydata = invSlots[| i];
    _keydata[@ eINVKEY.AVAILABLE] = false;
}

debug_log("oGAMEVARS USER0&gt; THIS METHOD IS NOT USED PLEASE");
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
