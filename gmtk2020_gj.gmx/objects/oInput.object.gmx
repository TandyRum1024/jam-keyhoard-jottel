<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input manager

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// singleton check
if (!singleton_update())
    exit;
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Declare input variables
/// Globally used inputs
enum eINPUT
{
    HLD = 0,
    PRS,
    REL,
    BIND
}

// keyboard
// (generic)
inputBindKeyboardL = vk_left;
inputBindKeyboardR = vk_right;
inputBindKeyboardU = vk_up;
inputBindKeyboardD = vk_down;
inputBindKeyboardConfirm = vk_enter;
inputBindKeyboardDeny    = vk_escape;
// (keyslot)
inputBindKeyboardKey1 = ord('Z');
inputBindKeyboardKey2 = ord('X');
inputBindKeyboardKey3 = ord('A');
inputBindKeyboardKey4 = ord('S');
inputBindKeyboardKey5 = vk_shift;

// gamepad
inputBindGamepadL = gp_padl;
inputBindGamepadR = gp_padr;
inputBindGamepadU = gp_padu;
inputBindGamepadD = gp_padd;
inputBindGamepadConfirm     = gp_select;
inputBindGamepadDeny        = gp_start;
inputBindGamepadConfirmAlt  = gp_face1; // A / CROSS button (for menu)
inputBindGamepadDenyAlt     = gp_face2; // B / CIRCLE button (for menu)
// (keyslot)
inputBindGamepadKey1 = gp_face1;
inputBindGamepadKey2 = gp_face2;
inputBindGamepadKey3 = gp_face3;
inputBindGamepadKey4 = gp_face4;
inputBindGamepadKey5 = makearray(gp_shoulderl, gp_shoulderlb, gp_shoulderr, gp_shoulderrb);

/// Key states : they're made of arrays so that we can refer it from other instances
// (like a pointer but.. hacky &amp; works in GMS1 I guess)
inputH = makearray(false, false, false);
inputV = makearray(false, false, false);
inputHPrev = 0;
inputVPrev = 0;
inputConfirm    = makearray(false, false, false); // yes
inputDeny       = makearray(false, false, false); // no
inputConfirmAlt = makearray(false, false, false); // yes
inputDenyAlt    = makearray(false, false, false); // no
// (keyslot)
inputKey1       = makearray(false, false, false);
inputKey2       = makearray(false, false, false);
inputKey3       = makearray(false, false, false);
inputKey4       = makearray(false, false, false);
inputKey5       = makearray(false, false, false);

/// Current / preferred input method
enum eINPUT_METHOD
{
    KEYBOARD = 0,
    GAMEPAD
}

// Table to convert the method index to string
inputMethodNameStr = -1;
inputMethodNameStr[eINPUT_METHOD.KEYBOARD] = "KEYBOARD";
inputMethodNameStr[eINPUT_METHOD.GAMEPAD] = "GAMEPAD";

// Current method
inputMethodCurrent = eINPUT_METHOD.KEYBOARD;

// Current input device
inputDevice = 0;

// Current gamepad vibration amount
inputVibration = 0;
inputVibrationDamp = 0.95;
inputVibrationAmplitude = 0.75;

/// Gamepad specific vars
inputGamepadList = ds_list_create();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup keyslot system
/// Enum : inventory key slot data
enum eINVKEY
{
    KEYSTATE = 0,   // key state : points to array w/ size of 3 that holds input's hold, press, release state
    AVAILABLE,      // is the slot available?
    ITEM            // item index
}

/// List of keyslots id
invKeyslotsIDList = ds_list_create();

/// Declare keyslots
invKeyslots = ds_map_create();
inv_key_add("BTN1", inputKey1);
inv_key_add("BTN2", inputKey2);
inv_key_add("BTN3", inputKey3);
inv_key_add("BTN4", inputKey4);
inv_key_add("BTN5", inputKey5);

/// Table of keys unlocking on each level
invKeysUnlock = makearray(
    makearray("BTN1", "BTN2"),
    makearray("BTN5"),
    makearray("BTN3"),
    makearray("BTN4")
    );
invKeysLevel = 0;

// Update key upgrade status
event_user(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free data structures
if (objectInitialized)
{
    ds_list_destroy(inputGamepadList);
    
    /// Key slot system
    if (ds_exists(invSlots, ds_type_map))
        ds_map_destroy(invSlots);
    if (ds_exists(invKeyslotsIDList, ds_type_list))
        ds_list_destroy(invKeyslotsIDList);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update input
/// Check for inputs
switch (inputMethodCurrent)
{
    case eINPUT_METHOD.KEYBOARD:
        /// Check for keyboard inputs
        // (horizontal)
        inputH[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardR) - keyboard_check(inputBindKeyboardL);
        inputH[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardR) - keyboard_check_pressed(inputBindKeyboardL);
        inputH[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardR) - keyboard_check_released(inputBindKeyboardL);
        
        // (vertical)
        inputV[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardD) - keyboard_check(inputBindKeyboardU);
        inputV[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardD) - keyboard_check_pressed(inputBindKeyboardU);
        inputV[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardD) - keyboard_check_released(inputBindKeyboardU);
        
        // (confirm)
        inputConfirm[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardConfirm);
        inputConfirm[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardConfirm);
        inputConfirm[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardConfirm);
        inputConfirmAlt[@ eINPUT.HLD] = false;
        inputConfirmAlt[@ eINPUT.PRS] = false;
        inputConfirmAlt[@ eINPUT.REL] = false;
        
        // (deny)
        inputDeny[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardDeny);
        inputDeny[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardDeny);
        inputDeny[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardDeny);
        inputDenyAlt[@ eINPUT.HLD] = false;
        inputDenyAlt[@ eINPUT.PRS] = false;
        inputDenyAlt[@ eINPUT.REL] = false;
        
        // (keyslots)
        inputKey1[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey1);
        inputKey1[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey1);
        inputKey1[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey1);
        inputKey2[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey2);
        inputKey2[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey2);
        inputKey2[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey2);
        inputKey3[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey3);
        inputKey3[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey3);
        inputKey3[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey3);
        inputKey4[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey4);
        inputKey4[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey4);
        inputKey4[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey4);
        inputKey5[@ eINPUT.HLD] = keyboard_check(inputBindKeyboardKey5);
        inputKey5[@ eINPUT.PRS] = keyboard_check_pressed(inputBindKeyboardKey5);
        inputKey5[@ eINPUT.REL] = keyboard_check_released(inputBindKeyboardKey5);
        break;
        
    case eINPUT_METHOD.GAMEPAD:
        /// Check for gamepad inputs
        inputHPrev = inputH[@ eINPUT.HLD];
        inputVPrev = inputV[@ eINPUT.HLD];
        
        // (horizontal)
        inputH[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadR) - gamepad_button_check(inputDevice, inputBindGamepadL);
        inputH[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadR) - gamepad_button_check_pressed(inputDevice, inputBindGamepadL);
        inputH[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadR) - gamepad_button_check_released(inputDevice, inputBindGamepadL);
        
        // (vertical)
        inputV[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadD) - gamepad_button_check(inputDevice, inputBindGamepadU);
        inputV[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadD) - gamepad_button_check_pressed(inputDevice, inputBindGamepadU);
        inputV[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadD) - gamepad_button_check_released(inputDevice, inputBindGamepadU);
        
        // (alternative joystick controls)
        if (inputH[@ eINPUT.HLD] == 0)
            inputH[@ eINPUT.HLD] = gamepad_axis_value(inputDevice, gp_axislh);
        if (inputV[@ eINPUT.HLD] == 0)
            inputV[@ eINPUT.HLD] = gamepad_axis_value(inputDevice, gp_axislv);
            
        if (inputH[@ eINPUT.PRS] == 0 &amp;&amp; (abs(inputHPrev) &lt;= math_get_epsilon() &amp;&amp; abs(inputH[@ eINPUT.HLD]) &gt; math_get_epsilon()))
        {
            // debug_log("oINPUT STEPBEGIN &gt; INPUTHPREV : ", abs(inputHPrev));
            inputH[@ eINPUT.PRS] = sign(inputH[@ eINPUT.HLD]);
        }
        if (inputV[@ eINPUT.PRS] == 0 &amp;&amp; (abs(inputVPrev) &lt;= math_get_epsilon() &amp;&amp; abs(inputV[@ eINPUT.HLD]) &gt; math_get_epsilon()))
        {
            // debug_log("oINPUT STEPBEGIN &gt; INPUTVPREV : ", abs(inputVPrev));
            inputV[@ eINPUT.PRS] = sign(inputV[@ eINPUT.HLD]);
        }
            
        if (inputH[@ eINPUT.REL] == 0 &amp;&amp; (abs(inputHPrev) &gt; math_get_epsilon() &amp;&amp; abs(inputH[@ eINPUT.HLD]) &lt;= math_get_epsilon()))
            inputH[@ eINPUT.REL] = sign(inputHPrev);
        if (inputV[@ eINPUT.REL] == 0 &amp;&amp; (abs(inputVPrev) &gt; math_get_epsilon() &amp;&amp; abs(inputV[@ eINPUT.HLD]) &lt;= math_get_epsilon()))
            inputV[@ eINPUT.REL] = sign(inputVPrev);
        
        // (confirm)
        inputConfirm[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadConfirm);
        inputConfirm[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadConfirm);
        inputConfirm[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadConfirm);
        inputConfirmAlt[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadConfirmAlt);
        inputConfirmAlt[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadConfirmAlt);
        inputConfirmAlt[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadConfirmAlt);
        
        // (deny)
        inputDeny[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadDeny);
        inputDeny[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadDeny);
        inputDeny[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadDeny);
        inputDenyAlt[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadDenyAlt);
        inputDenyAlt[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadDenyAlt);
        inputDenyAlt[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadDenyAlt);
        
        // (keyslots)
        inputKey1[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadKey1);
        inputKey1[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadKey1);
        inputKey1[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadKey1);
        
        inputKey2[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadKey2);
        inputKey2[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadKey2);
        inputKey2[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadKey2);
        
        inputKey3[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadKey3);
        inputKey3[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadKey3);
        inputKey3[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadKey3);
        
        inputKey4[@ eINPUT.HLD] = gamepad_button_check(inputDevice, inputBindGamepadKey4);
        inputKey4[@ eINPUT.PRS] = gamepad_button_check_pressed(inputDevice, inputBindGamepadKey4);
        inputKey4[@ eINPUT.REL] = gamepad_button_check_released(inputDevice, inputBindGamepadKey4);
        
        inputKey5[@ eINPUT.HLD] = false;
        inputKey5[@ eINPUT.PRS] = false;
        inputKey5[@ eINPUT.REL] = false;
        for (var i=0; i&lt;array_length_1d(inputBindGamepadKey5); i++)
        {
            var _btn = inputBindGamepadKey5[@ i];
            inputKey5[@ eINPUT.HLD] |= gamepad_button_check(inputDevice, _btn);
            inputKey5[@ eINPUT.PRS] |= gamepad_button_check_pressed(inputDevice, _btn);
            inputKey5[@ eINPUT.REL] |= gamepad_button_check_released(inputDevice, _btn);
        }
        break;
}

// Detect gamepad input
for (var i=0; i&lt;ds_list_size(inputGamepadList); i++)
{
    var _pad = inputGamepadList[| i];
    if (input_check_gamepad_anybutton_pressed(_pad) != -1)
    {
        if (inputDevice != _pad || inputMethodCurrent == eINPUT_METHOD.KEYBOARD)
        {
            // If any input was detected on current gamepad,
            // make it as the current input device and set input method to gamepad
            inputMethodCurrent = eINPUT_METHOD.GAMEPAD;
            inputDevice = _pad;
            
            // Show input detection popup
            with (oUI)
            {
                event_user(0);
            }
            
        }
        debug_log("oINPUT &gt; GAMEPAD INPUT DETECTED ON GP#", _pad, "!");
        
        // Set layout as gamepad
        if (inputDevice &lt;= 3) // xbox / xinput
        {
            debug_log("   &gt; GP TYPE : XBOX/XINPUT");
        }
        else
        {
            debug_log("   &gt; GP TYPE : PS/DINPUT");
        }
    }
}

// Detect keyboard input
if (inputMethodCurrent == eINPUT_METHOD.GAMEPAD)
{
    if (keyboard_check_pressed(vk_anykey))
    {
        // If any input was detected on keyboard,
        // make it as the current input device and set input method to keyboard
        inputMethodCurrent = eINPUT_METHOD.KEYBOARD;
        inputDevice = -1;
        
        // Show input detection popup
        with (oUI)
        {
            event_user(0);
        }
        
        debug_log("oINPUT &gt; KEYBOARD DETECTED!");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update gamepad vibration
gamepad_set_vibration(inputDevice, inputVibration * inputVibrationAmplitude, inputVibration * inputVibrationAmplitude);
inputVibration *= inputVibrationDamp;
if (inputVibration &lt;= 0.01)
    inputVibration = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for gamepad connection
var _eventtype = async_load[? "event_type"];

switch (_eventtype)
{
    case "gamepad discovered": // Detected gamepad connection
        var _padindex = async_load[? "pad_index"];
        // Check if there's any gamepad present in the connected gamepad list
        // and add it to the list of connected gamepad list if not present
        var _padlistidx = ds_list_find_index(inputGamepadList, _padindex);
        if (_padlistidx == -1)
        {
            ds_list_add(inputGamepadList, _padindex);
        }
        
        // Reset vibration to 0
        gamepad_set_vibration(_padindex, 0, 0);
        
        // Set input method to gamepad &amp; set current input device to
        // connected gamepad
        inputMethodCurrent = eINPUT_METHOD.GAMEPAD;
        inputDevice = _padindex;
        
        // Detect small joystick drift &amp; set the deadzone automatically
        var _inputmag = min(point_distance(0, 0, gamepad_axis_value(inputDevice, gp_axislh), gamepad_axis_value(inputDevice, gp_axislv)), 0.1);
        gamepad_set_axis_deadzone(inputDevice, _inputmag);
        
        // Show input detection popup
        with (oUI)
        {
            event_user(0);
        }
        
        debug_log("GAMEPAD DETECTED!");
        break;
        
    case "gamepad lost": // Lost gamepad connection
        var _padindex = async_load[? "pad_index"];
        // Check if there's any gamepad present in the connected gamepad list
        // and remove it from the list of connected gamepad list if present
        var _padlistidx = ds_list_find_index(inputGamepadList, _padindex);
        if (_padlistidx != -1)
        {
            ds_list_delete(inputGamepadList, _padlistidx);
        }
        
        // Set input method to keyboard
        // if there's no more gamepads present in the list of connected devices
        if (ds_list_empty(inputGamepadList))
        {
            inputMethodCurrent = eINPUT_METHOD.KEYBOARD;
            inputDevice = -1;
        }
        else
        {
            // Otherwise, set the input device to recently connected gamepad
            inputDevice = inputGamepadList[| ds_list_size(inputGamepadList)];
        }
        
        // Show input detection popup
        with (oUI)
        {
            event_user(0);
        }
        
        debug_log("GAMEPAD LOST!");
        break;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update key slots upgrade status
event_user(0);

invKeysLevel = clamp(invKeysLevel, 0, array_length_1d(invKeysUnlock) - 1);
for (var i=0; i&lt;=invKeysLevel; i++)
{
    var _unlocks = invKeysUnlock[@ i];
    for (var j=0; j&lt;array_length_1d(_unlocks); j++)
    {
        var _slotid = _unlocks[@ j];
        debug_log("oINPUT USER1 &gt; unlocking key slot [", _slotid, "]...");
        inv_key_set_available(_slotid, true);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset key slots upgrade status
var _key = ds_map_find_first(invKeyslots);
while (_key != undefined)
{
    inv_key_set_available(_key, false);
    _key = ds_map_find_next(invKeyslots, _key);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
